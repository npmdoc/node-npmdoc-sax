<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/isaacs/sax-js#readme">sax (v1.2.2)</a>
</h1>
<h4>An evented streaming XML parser in JavaScript</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.sax">module sax</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sax.SAXParser">
            function <span class="apidocSignatureSpan">sax.</span>SAXParser
            <span class="apidocSignatureSpan">(strict, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sax.SAXStream">
            function <span class="apidocSignatureSpan">sax.</span>SAXStream
            <span class="apidocSignatureSpan">(strict, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sax.createStream">
            function <span class="apidocSignatureSpan">sax.</span>createStream
            <span class="apidocSignatureSpan">(strict, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sax.parser">
            function <span class="apidocSignatureSpan">sax.</span>parser
            <span class="apidocSignatureSpan">(strict, opt)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">sax.</span>MAX_BUFFER_LENGTH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sax.</span>ENTITIES</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sax.</span>EVENTS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sax.</span>SAXParser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sax.</span>SAXStream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sax.</span>STATE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sax.</span>XML_ENTITIES</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sax.SAXParser">module sax.SAXParser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sax.SAXParser.SAXParser">
            function <span class="apidocSignatureSpan">sax.</span>SAXParser
            <span class="apidocSignatureSpan">(strict, opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sax.SAXParser.prototype">module sax.SAXParser.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sax.SAXParser.prototype.close">
            function <span class="apidocSignatureSpan">sax.SAXParser.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sax.SAXParser.prototype.end">
            function <span class="apidocSignatureSpan">sax.SAXParser.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sax.SAXParser.prototype.flush">
            function <span class="apidocSignatureSpan">sax.SAXParser.prototype.</span>flush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sax.SAXParser.prototype.resume">
            function <span class="apidocSignatureSpan">sax.SAXParser.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sax.SAXParser.prototype.write">
            function <span class="apidocSignatureSpan">sax.SAXParser.prototype.</span>write
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sax.SAXStream">module sax.SAXStream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sax.SAXStream.SAXStream">
            function <span class="apidocSignatureSpan">sax.</span>SAXStream
            <span class="apidocSignatureSpan">(strict, opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sax.SAXStream.prototype">module sax.SAXStream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sax.SAXStream.prototype.end">
            function <span class="apidocSignatureSpan">sax.SAXStream.prototype.</span>end
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sax.SAXStream.prototype.on">
            function <span class="apidocSignatureSpan">sax.SAXStream.prototype.</span>on
            <span class="apidocSignatureSpan">(ev, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sax.SAXStream.prototype.write">
            function <span class="apidocSignatureSpan">sax.SAXStream.prototype.</span>write
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sax" id="apidoc.module.sax">module sax</a></h1>


    <h2>
        <a href="#apidoc.element.sax.SAXParser" id="apidoc.element.sax.SAXParser">
        function <span class="apidocSignatureSpan">sax.</span>SAXParser
        <span class="apidocSignatureSpan">(strict, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SAXParser(strict, opt) {
  if (!(this instanceof SAXParser)) {
    return new SAXParser(strict, opt)
  }

  var parser = this
  clearBuffers(parser)
  parser.q = parser.c = ''
  parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
  parser.opt = opt || {}
  parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
  parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
  parser.tags = []
  parser.closed = parser.closedRoot = parser.sawRoot = false
  parser.tag = parser.error = null
  parser.strict = !!strict
  parser.noscript = !!(strict || parser.opt.noscript)
  parser.state = S.BEGIN
  parser.strictEntities = parser.opt.strictEntities
  parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
  parser.attribList = []

  // namespaces form a prototype chain.
  // it always points at the current tag,
  // which protos to its parent tag.
  if (parser.opt.xmlns) {
    parser.ns = Object.create(rootNS)
  }

  // mostly just for error reporting
  parser.trackPosition = parser.opt.position !== false
  if (parser.trackPosition) {
    parser.position = parser.line = parser.column = 0
  }
  emit(parser, 'onready')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sax.SAXStream" id="apidoc.element.sax.SAXStream">
        function <span class="apidocSignatureSpan">sax.</span>SAXStream
        <span class="apidocSignatureSpan">(strict, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SAXStream(strict, opt) {
  if (!(this instanceof SAXStream)) {
    return new SAXStream(strict, opt)
  }

  Stream.apply(this)

  this._parser = new SAXParser(strict, opt)
  this.writable = true
  this.readable = true

  var me = this

  this._parser.onend = function () {
    me.emit('end')
  }

  this._parser.onerror = function (er) {
    me.emit('error', er)

    // if didn't throw, then means error was handled.
    // go ahead and clear error, so we can write again.
    me._parser.error = null
  }

  this._decoder = null

  streamWraps.forEach(function (ev) {
    Object.defineProperty(me, 'on' + ev, {
      get: function () {
        return me._parser['on' + ev]
      },
      set: function (h) {
        if (!h) {
          me.removeAllListeners(ev)
          me._parser['on' + ev] = h
          return h
        }
        me.on(ev, h)
      },
      enumerable: true,
      configurable: false
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sax.createStream" id="apidoc.element.sax.createStream">
        function <span class="apidocSignatureSpan">sax.</span>createStream
        <span class="apidocSignatureSpan">(strict, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createStream(strict, opt) {
  return new SAXStream(strict, opt)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// parser stream is done, and ready to have more stuff written to it.
};

parser.write('&lt;xml&gt;Hello, &lt;who name="world"&gt;world&lt;/who&gt;!&lt;/xml&gt;').close
();

// stream usage
// takes the same options as the parser
var saxStream = require("sax").<span class="apidocCodeKeywordSpan">createStream</span>(strict, options)
saxStream.on("error", function (e) {
// unhandled errors will throw, since this is a proper node
// event emitter.
console.error("error!", e)
// clear the error
this._parser.error = null
this._parser.resume()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sax.parser" id="apidoc.element.sax.parser">
        function <span class="apidocSignatureSpan">sax.</span>parser
        <span class="apidocSignatureSpan">(strict, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parser = function (strict, opt) { return new SAXParser(strict, opt) }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
through unmolested.

## Usage

```javascript
var sax = require("./lib/sax"),
  strict = true, // set to false for html-mode
  parser = sax.<span class="apidocCodeKeywordSpan">parser</span>(strict);

parser.onerror = function (e) {
  // an error happened.
};
parser.ontext = function (t) {
  // got some text.  t is the string of text.
};
...</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sax.SAXParser" id="apidoc.module.sax.SAXParser">module sax.SAXParser</a></h1>


    <h2>
        <a href="#apidoc.element.sax.SAXParser.SAXParser" id="apidoc.element.sax.SAXParser.SAXParser">
        function <span class="apidocSignatureSpan">sax.</span>SAXParser
        <span class="apidocSignatureSpan">(strict, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SAXParser(strict, opt) {
  if (!(this instanceof SAXParser)) {
    return new SAXParser(strict, opt)
  }

  var parser = this
  clearBuffers(parser)
  parser.q = parser.c = ''
  parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
  parser.opt = opt || {}
  parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
  parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
  parser.tags = []
  parser.closed = parser.closedRoot = parser.sawRoot = false
  parser.tag = parser.error = null
  parser.strict = !!strict
  parser.noscript = !!(strict || parser.opt.noscript)
  parser.state = S.BEGIN
  parser.strictEntities = parser.opt.strictEntities
  parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
  parser.attribList = []

  // namespaces form a prototype chain.
  // it always points at the current tag,
  // which protos to its parent tag.
  if (parser.opt.xmlns) {
    parser.ns = Object.create(rootNS)
  }

  // mostly just for error reporting
  parser.trackPosition = parser.opt.position !== false
  if (parser.trackPosition) {
    parser.position = parser.line = parser.column = 0
  }
  emit(parser, 'onready')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sax.SAXParser.prototype" id="apidoc.module.sax.SAXParser.prototype">module sax.SAXParser.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.sax.SAXParser.prototype.close" id="apidoc.element.sax.SAXParser.prototype.close">
        function <span class="apidocSignatureSpan">sax.SAXParser.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () { return this.write(null) }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
parser.onattribute = function (attr) {
// an attribute.  attr has "name" and "value"
};
parser.onend = function () {
// parser stream is done, and ready to have more stuff written to it.
};

parser.write('&lt;xml&gt;Hello, &lt;who name="world"&gt;world&lt;/who&gt;!&lt;/xml&gt;').<span class="apidocCodeKeywordSpan">close</span>();

// stream usage
// takes the same options as the parser
var saxStream = require("sax").createStream(strict, options)
saxStream.on("error", function (e) {
// unhandled errors will throw, since this is a proper node
// event emitter.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sax.SAXParser.prototype.end" id="apidoc.element.sax.SAXParser.prototype.end">
        function <span class="apidocSignatureSpan">sax.SAXParser.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function () { end(this) }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return true
}

SAXStream.prototype.end = function (chunk) {
  if (chunk &amp;&amp; chunk.length) {
    this.write(chunk)
  }
  this._parser.<span class="apidocCodeKeywordSpan">end</span>()
  return true
}

SAXStream.prototype.on = function (ev, handler) {
  var me = this
  if (!me._parser['on' + ev] &amp;&amp; streamWraps.indexOf(ev) !== -1) {
    me._parser['on' + ev] = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sax.SAXParser.prototype.flush" id="apidoc.element.sax.SAXParser.prototype.flush">
        function <span class="apidocSignatureSpan">sax.SAXParser.prototype.</span>flush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function () { flushBuffers(this) }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sax.SAXParser.prototype.resume" id="apidoc.element.sax.SAXParser.prototype.resume">
        function <span class="apidocSignatureSpan">sax.SAXParser.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () { this.error = null; return this }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var saxStream = require("sax").createStream(strict, options)
saxStream.on("error", function (e) {
  // unhandled errors will throw, since this is a proper node
  // event emitter.
  console.error("error!", e)
  // clear the error
  this._parser.error = null
  this._parser.<span class="apidocCodeKeywordSpan">resume</span>()
})
saxStream.on("opentag", function (node) {
  // same object as above
})
// pipe is supported, and it's readable/writable
// same chunks coming in also go out.
fs.createReadStream("file.xml")
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sax.SAXParser.prototype.write" id="apidoc.element.sax.SAXParser.prototype.write">
        function <span class="apidocSignatureSpan">sax.SAXParser.prototype.</span>write
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write(chunk) {
  var parser = this
  if (this.error) {
    throw this.error
  }
  if (parser.closed) {
    return error(parser,
      'Cannot write after close. Assign an onready handler.')
  }
  if (chunk === null) {
    return end(parser)
  }
  if (typeof chunk === 'object') {
    chunk = chunk.toString()
  }
  var i = 0
  var c = ''
  while (true) {
    c = charAt(chunk, i++)
    parser.c = c

    if (!c) {
      break
    }

    if (parser.trackPosition) {
      parser.position++
      if (c === '\n') {
        parser.line++
        parser.column = 0
      } else {
        parser.column++
      }
    }

    switch (parser.state) {
      case S.BEGIN:
        parser.state = S.BEGIN_WHITESPACE
        if (c === '\uFEFF') {
          continue
        }
        beginWhiteSpace(parser, c)
        continue

      case S.BEGIN_WHITESPACE:
        beginWhiteSpace(parser, c)
        continue

      case S.TEXT:
        if (parser.sawRoot &amp;&amp; !parser.closedRoot) {
          var starti = i - 1
          while (c &amp;&amp; c !== '&lt;' &amp;&amp; c !== '&amp;') {
            c = charAt(chunk, i++)
            if (c &amp;&amp; parser.trackPosition) {
              parser.position++
              if (c === '\n') {
                parser.line++
                parser.column = 0
              } else {
                parser.column++
              }
            }
          }
          parser.textNode += chunk.substring(starti, i - 1)
        }
        if (c === '&lt;' &amp;&amp; !(parser.sawRoot &amp;&amp; parser.closedRoot &amp;&amp; !parser.strict)) {
          parser.state = S.OPEN_WAKA
          parser.startTagPosition = parser.position
        } else {
          if (not(whitespace, c) &amp;&amp; (!parser.sawRoot || parser.closedRoot)) {
            strictFail(parser, 'Text data outside of root node.')
          }
          if (c === '&amp;') {
            parser.state = S.TEXT_ENTITY
          } else {
            parser.textNode += c
          }
        }
        continue

      case S.SCRIPT:
        // only non-strict
        if (c === '&lt;') {
          parser.state = S.SCRIPT_ENDING
        } else {
          parser.script += c
        }
        continue

      case S.SCRIPT_ENDING:
        if (c === '/') {
          parser.state = S.CLOSE_TAG
        } else {
          parser.script += '&lt;' + c
          parser.state = S.SCRIPT
        }
        continue

      case S.OPEN_WAKA:
        // either a /, ?, !, or text is coming next.
        if (c === '!') {
          parser.state = S.SGML_DECL
          parser.sgmlDecl = ''
        } else if (is(whitespace, c)) {
          // wait for it...
        } else if (isMatch(nameStart, c)) {
          parser.state = S.OPEN_TAG
          parser.tagName = c
        } else if (c === '/') {
          parser.state = S.CLOSE_TAG
          parser.tagName = ''
        } else if (c === '?') {
          parser.state = S.PROC_INST
          parser.procInstName = parser.procInstBody = ''
        } else {
          strictFail(parser, 'Unencoded &lt;')
          // if there was some whitespace, then add that in.
          if (parser.startTagPosition + 1 &lt; parser.position) {
            var pad = parser.position - parser.startTagPosition
            c = new Array(pad).join(' ') + c
          }
          parser.textNode += '&lt;' + c
          parser.state = S.TEXT
        }
        continue

      case S.SGML_DECL:
        if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
          emitNode(parser, 'onopencdata')
          parser.state = S.CDATA
          parser.sgmlDecl = ''
          parser.cdata = ''
        } else if (parser.sgmlDecl + c === '--') {
          parser.state = S.COMMENT
          parser.comment = ''
          parser.sgmlDecl = ''
        } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
          parser.state = S.DOCTYPE
          if (parser.doctype || parser.sawRoot) {
            strictFail(parser,
              'Inappropriately located doctype declaration')
          }
          parser.doctype = ''
          parser.sgmlDecl = ''
        } else if (c === '&gt;') {
          emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl) ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
parser.onattribute = function (attr) {
// an attribute.  attr has "name" and "value"
};
parser.onend = function () {
// parser stream is done, and ready to have more stuff written to it.
};

parser.<span class="apidocCodeKeywordSpan">write</span>('&lt;xml&gt;Hello, &lt;who name="world"&gt;world&amp;#
x3c;/who&gt;!&lt;/xml&gt;').close();

// stream usage
// takes the same options as the parser
var saxStream = require("sax").createStream(strict, options)
saxStream.on("error", function (e) {
// unhandled errors will throw, since this is a proper node
// event emitter.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sax.SAXStream" id="apidoc.module.sax.SAXStream">module sax.SAXStream</a></h1>


    <h2>
        <a href="#apidoc.element.sax.SAXStream.SAXStream" id="apidoc.element.sax.SAXStream.SAXStream">
        function <span class="apidocSignatureSpan">sax.</span>SAXStream
        <span class="apidocSignatureSpan">(strict, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SAXStream(strict, opt) {
  if (!(this instanceof SAXStream)) {
    return new SAXStream(strict, opt)
  }

  Stream.apply(this)

  this._parser = new SAXParser(strict, opt)
  this.writable = true
  this.readable = true

  var me = this

  this._parser.onend = function () {
    me.emit('end')
  }

  this._parser.onerror = function (er) {
    me.emit('error', er)

    // if didn't throw, then means error was handled.
    // go ahead and clear error, so we can write again.
    me._parser.error = null
  }

  this._decoder = null

  streamWraps.forEach(function (ev) {
    Object.defineProperty(me, 'on' + ev, {
      get: function () {
        return me._parser['on' + ev]
      },
      set: function (h) {
        if (!h) {
          me.removeAllListeners(ev)
          me._parser['on' + ev] = h
          return h
        }
        me.on(ev, h)
      },
      enumerable: true,
      configurable: false
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sax.SAXStream.prototype" id="apidoc.module.sax.SAXStream.prototype">module sax.SAXStream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.sax.SAXStream.prototype.end" id="apidoc.element.sax.SAXStream.prototype.end">
        function <span class="apidocSignatureSpan">sax.SAXStream.prototype.</span>end
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function (chunk) {
  if (chunk &amp;&amp; chunk.length) {
    this.write(chunk)
  }
  this._parser.end()
  return true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return true
}

SAXStream.prototype.end = function (chunk) {
  if (chunk &amp;&amp; chunk.length) {
    this.write(chunk)
  }
  this._parser.<span class="apidocCodeKeywordSpan">end</span>()
  return true
}

SAXStream.prototype.on = function (ev, handler) {
  var me = this
  if (!me._parser['on' + ev] &amp;&amp; streamWraps.indexOf(ev) !== -1) {
    me._parser['on' + ev] = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sax.SAXStream.prototype.on" id="apidoc.element.sax.SAXStream.prototype.on">
        function <span class="apidocSignatureSpan">sax.SAXStream.prototype.</span>on
        <span class="apidocSignatureSpan">(ev, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (ev, handler) {
  var me = this
  if (!me._parser['on' + ev] &amp;&amp; streamWraps.indexOf(ev) !== -1) {
    me._parser['on' + ev] = function () {
      var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)
      args.splice(0, 0, ev)
      me.emit.apply(me, args)
    }
  }

  return Stream.prototype.on.call(me, ev, handler)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

parser.write('&lt;xml&gt;Hello, &lt;who name="world"&gt;world&lt;/who&gt;!&lt;/xml&gt;').close
();

// stream usage
// takes the same options as the parser
var saxStream = require("sax").createStream(strict, options)
saxStream.<span class="apidocCodeKeywordSpan">on</span>("error", function (e) {
  // unhandled errors will throw, since this is a proper node
  // event emitter.
  console.error("error!", e)
  // clear the error
  this._parser.error = null
  this._parser.resume()
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sax.SAXStream.prototype.write" id="apidoc.element.sax.SAXStream.prototype.write">
        function <span class="apidocSignatureSpan">sax.SAXStream.prototype.</span>write
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (data) {
  if (typeof Buffer === 'function' &amp;&amp;
    typeof Buffer.isBuffer === 'function' &amp;&amp;
    Buffer.isBuffer(data)) {
    if (!this._decoder) {
      var SD = require('string_decoder').StringDecoder
      this._decoder = new SD('utf8')
    }
    data = this._decoder.write(data)
  }

  this._parser.write(data.toString())
  this.emit('data', data)
  return true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
parser.onattribute = function (attr) {
// an attribute.  attr has "name" and "value"
};
parser.onend = function () {
// parser stream is done, and ready to have more stuff written to it.
};

parser.<span class="apidocCodeKeywordSpan">write</span>('&lt;xml&gt;Hello, &lt;who name="world"&gt;world&amp;#
x3c;/who&gt;!&lt;/xml&gt;').close();

// stream usage
// takes the same options as the parser
var saxStream = require("sax").createStream(strict, options)
saxStream.on("error", function (e) {
// unhandled errors will throw, since this is a proper node
// event emitter.
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>